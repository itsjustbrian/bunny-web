import * as Util from './util.js';

const LAG_TOLERANCE = 0.01666666666; // 1 Frame at 60fps
const MAX_BUFFER_LENGTH = 20; // Seconds
const BUFFER_REMOVAL_CUSHION = 4; // Seconds

export class VideoPlayer {
  constructor(element) {
    this.element = element;
    this.videoSource = null;
    this.mediaSource = null;
    this._lastSegment = null;
    this.listeners = [];
  }

  _submit() {
    if (!this.initialized) this.initialized = true;

    if (this.videoSource.updating) return;

    if (this._lastSegment) {
      this._appendBuffer(this._lastSegment);
      delete this._lastSegment;
      return;
    }

    if (this.element.buffered.length) {
      const currentTime = this.element.currentTime;
      const bufferStart = this.element.buffered.start(0);
      const bufferEnd = this.element.buffered.end(0);
      if (currentTime - bufferStart > MAX_BUFFER_LENGTH && currentTime < bufferEnd) {
        this.videoSource.remove(bufferStart, currentTime - BUFFER_REMOVAL_CUSHION);
      }
    }
  }

  _appendBuffer(frame) {
    try {
      this.videoSource.appendBuffer(frame);
    } catch (error) {
      console.error(error);
      this.destroy();
    }
  }

  _init(initSegment) {
    console.log('init run')
    this.mediaSource = new MediaSource();
    this.element.src = URL.createObjectURL(this.mediaSource);
    this.element.load();

    this.listeners.push(Util.addListener(this.element, 'error', () => {
      console.error(this.element.error.message);
    }));

    this.listeners.push(Util.addListener(this.mediaSource, 'sourceopen', () => {
      console.log('source open');
      this.videoSource = this.mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42C01F"');
      this.videoSource.mode = 'sequence';
      this.videoSource.onerror = (err) => {
        console.error('Error in video source', err);
      };
      this.listeners.push(Util.addListener(this.videoSource, 'update', this._submit, this));
      this.element.play();
      this.videoSource.appendBuffer(initSegment);
    }));
  }

  destroy() {
    this.initialized = false;

    this.element.pause();

    Util.removeListeners(this.listeners);
    this.listeners = [];

    if (this.mediaSource) {
      if (this.videoSource) {
        this.mediaSource.removeSourceBuffer(this.videoSource);
        this.videoSource = null;
      }

      this.mediaSource.endOfStream();
      URL.revokeObjectURL(this.element.src);
      this.mediaSource = null;
    }
  }

  _reinit(initSegment) {
    this.destroy();
    this._init(initSegment);
  }

  push(data) {
    if (data[4] === 0x66) {
      console.log('hi');
      this._reinit(data); // Got initialization segment
    }
    if (!this.initialized) return;
    if (this.videoSource.buffered.length) {
      const currentTime = this.element.currentTime;
      const bufferEnd = this.element.buffered.end(0);
      if (currentTime < bufferEnd - LAG_TOLERANCE)
        this.element.currentTime = bufferEnd - LAG_TOLERANCE;
    }
    if (this.videoSource.updating) this._lastSegment = data;
    else {
      delete this._lastSegment;
      console.log('appending buff');
      this._appendBuffer(data);
    }
  }
}
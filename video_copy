import * as Util from './util.js';

export class VideoPlayer {
  constructor(element, onFatal) {
    this.element = element;
    this.onFatal = onFatal;
    this.videoSource = null;
    this.mediaSource = null;
    this.waitingForInitSegment = true;
    this.listeners = [];
    this.queue = [];
  }

  getQ() {
    console.log(this.queue.length);
    console.log(this.queue);
  }

  getMode() {
    console.log(this.videoSource.mode);
  }

  _submit() {
    if (!this.videoSource || this.videoSource.updating) return;

    // if (this.videoSource && !this.videoSource.updating && this.element.buffered.length && this.element.currentTime - this.element.buffered.start(0) > (0.01666666666 * 10)) {
    //   this.videoSource.remove(this.element.buffered.start(0), this.element.currentTime - (0.01666666666 * 10))
    // }

    if (this.queuedInitSegment || this.queue.length > 0) {
      // if (this.videoSource && !this.videoSource.updating &&
      //     (this.queuedInitSegment ||
      //       (this.queue.length > 0 && (this.waiting || !this.element.buffered.length || this.element.currentTime > this.element.buffered.end(0) - (0.01666666666 * 1))))) {
      try {
        let frame;
        if (this.queuedInitSegment) {
          frame = this.queuedInitSegment;
          this.queuedInitSegment = null;
        } else {
          frame = this.queue.shift();
        }
        console.log('appending frame');
        this.videoSource.appendBuffer(frame);
        return;
      } catch (error) {
        console.warn(error);
        this.destroy();
        this.onFatal();
      }
    }

    if (this.element.buffered.length) {
      if (this.element.currentTime < this.element.buffered.end(0) - (0.01666666666 * 1))
        this.element.currentTime = this.element.buffered.end(0) - (0.01666666666 * 1);

      if (this.element.currentTime - this.element.buffered.start(0) > 20 && this.element.currentTime < this.element.buffered.end(0)) {
        this.videoSource.remove(this.element.buffered.start(0), this.element.currentTime - 4);
      }
    }
  }

  _init() {
    this.mediaSource = new MediaSource();
    this.element.src = URL.createObjectURL(this.mediaSource);

    // this.element.addEventListener('playing', () => this.waiting = false);
    // this.element.addEventListener('waiting', () => this.waiting = true);

    this.element.load();

    this.listeners.push(Util.addListener(this.element, 'error', () => {
      console.error(this.element.error.message);
    }));

    this.listeners.push(Util.addListener(this.mediaSource, 'sourceopen', () => {
      this.videoSource = this.mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42C01F"');
      this.videoSource.mode = 'sequence';
      this.videoSource.onerror = (err) => {
        console.error('Error in video source', err);
      };
      this.listeners.push(Util.addListener(this.videoSource, 'update', this._submit, this));
      this.element.play();
    }));
  }

  _reinit() {
    this.destroy();
    this._init();
  }

  destroy() {
    this.waitingForInitSegment = true;

    // this.element.removeEventListener('ended',   () => console.log('ended'));
    // this.element.removeEventListener('stalled', () => console.log('stalled'));
    // this.element.removeEventListener('playing', () => console.log('playing'));
    // this.element.removeEventListener('waiting', () => console.log('waiting'));

    this.element.pause();

    Util.removeListeners(this.listeners);
    this.listeners = [];

    if (this.mediaSource) {
      if (this.videoSource) {
        this.mediaSource.removeSourceBuffer(this.videoSource);
        this.videoSource = null;
      }

      this.mediaSource.endOfStream();
      URL.revokeObjectURL(this.element.src);
      this.mediaSource = null;
    }
  }

  push(data) {
    const frame = new Uint8Array(data);

    // Init segment
    if (frame[4] === 0x66) {
      console.log('got init');
      this._reinit();
      this.waitingForInitSegment = false;
    }

    if (!this.waitingForInitSegment) {
      if (frame[4] === 0x66) {
        this.queuedInitSegment = frame;
      } else {
        if (this.queue.length >= 2) this.queue.shift();
        this.queue.push(frame);
      }
      this._submit();
    }
  }
}